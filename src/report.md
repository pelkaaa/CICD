# Basic CI/CD

Разработка простого **CI/CD** для проекта *SimpleBashUtils*. Сборка, тестирование, развертывание.


## Contents

   1. [Настройка gitlab-runner](#part-1-настройка-gitlab-runner)  
   2. [Сборка](#part-2-сборка)  
   3. [Тест кодстайла](#part-3-тест-кодстайла)   
   4. [Интеграционные тесты](#part-4-интеграционные-тесты)  
   5. [Этап деплоя](#part-5-этап-деплоя)  
   6. [Дополнительно. Уведомления](#part-6-дополнительно-уведомления)

### Part 1. Настройка **gitlab-runner**

**== Задание ==**

##### Поднять виртуальную машину *Ubuntu Server 20.04 LTS*

* ``lsb_release -a``

![1](screens/1.png)

##### Скачать и установить на виртуальную машину **gitlab-runner**

* Установим необходимые пакеты 

``sudo apt install gcc``

``sudo apt install make``

``sudo apt install clang-format``

* Скачиваем и устанавливаем **gitlab-runner**

``sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64"``

``sudo chmod +x /usr/local/bin/gitlab-runner``

``sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash``

``sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner``

![2](screens/2.png)

##### Запустить **gitlab-runner** и зарегистрировать его для использования в текущем проекте (*DO6_CICD*)

* Регестрируем 

``sudo gitlab-runner register``

``Register the runner with this URL``

``registration token``

``description - DO6_CICD`` 

``Tegs - build,style,test,deploy``

``options - -``

``terminal - Shell`` 

![3](screens/3.png)

* Запускаем 

``sudo gitlab-runner verify``

``sudo gitlab-runner run``

### Part 2. Сборка

**== Задание ==**

#### Написать этап для **CI** по сборке приложений из проекта *C2_SimpleBashUtils*:

* Создаем фаил ``.gitlab-ci.yml`` в папке проекта

##### В файле _gitlab-ci.yml_ добавить этап запуска сборки через мейк файл из проекта C2

##### Файлы, полученные после сборки (артефакты), сохранять в произвольную директорию со сроком хранения 30 дней.

![4](screens/4.png)

* Добавляем ``cat`` и ``grep`` в ``src`` 

![5](screens/5.png)

* Пушим и проверяем 

![6](screens/6.png)

![7](screens/7.png)

![8](screens/8.png)

### Part 3. Тест кодстайла

**== Задание ==**

#### Написать этап для **CI**, который запускает скрипт кодстайла (*clang-format*):

![9](screens/9.png)

![10](screens/10.png)

* #### Если кодстайл не прошел, то "зафейлить" пайплайн 

* Меняю ``cat`` чтобы проверить работу скрипта 

![12](screens/12.png)

![14](screens/14.png)

* Возвращаем 

![11](screens/11.png)

##### В пайплайне отобразить вывод утилиты *clang-format* 

``clang-format -n -style=google src/**/*.c src/**/*.h`` 

![15](screens/15.png)


### Part 4. Интеграционные тесты

**== Задание ==**

#### Написать этап для **CI**, который запускает ваши интеграционные тесты из того же проекта:

##### В пайплайне отобразить вывод, что интеграционные тесты успешно прошли / провалились

![17](screens/17.png)

![40](screens/40.png)

> Показываю что тест не проходит в пустую и может зафейлится 

* Так же либо меняем тесты чтобы они были все успешны на линуксе или прописываем подобные костыли

![42](screens/42.png)

* Проверяем

![41](screens/41.png)

> Запускать этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно

![16](screens/16.png)

### Part 5. Этап деплоя

**== Задание ==**

##### Поднять вторую виртуальную машину *Ubuntu Server 20.04 LTS*

![18](screens/18.png)

#### Написать этап для **CD**, который "разворачивает" проект на другой виртуальной машине:

##### Запускать этот этап вручную при условии, что все предыдущие этапы прошли успешно

* Настриваем сеть между двумя машинами 

* 1 создаем нетплан 

![20](screens/20.png)

![24](screens/24.png)

* 2 подключаем машины друг к другу по shh 

   * 2.1 гинерим ключи 

  *  2.2 подключаем ключ на второй машине командой ``ssh-copy-id username@remote_host``

  *  2.3так же заходим под пользователем git-runner ``sudo su git-runner`` на первой машине и подключаем его ко второй по ssh как в пункте выше 

> Это нужно, чтобы он не запрашивал пароль при выполнении скрипта и все проходило 

> P.s. Если при удалении и создании нового ранера пайплайны не проходят, то можно использовать следующие команды ``sudo gitlab-runner unregister  -t token   -u url`` и ``sudo gitlab-runner verify --delete -t token   -u url``

* Пингуем их друг с другом чтобы проверить соединение 

![22](screens/22.png)

![23](screens/23.png)

##### Написать bash-скрипт, который при помощи **ssh** и **scp** копирует файлы, полученные после сборки (артефакты), в директорию */usr/local/bin* второй виртуальной машины

![29](screens/29.png)

> Будьте готовы объяснить по скрипту, как происходит перенос.

##### В файле _gitlab-ci.yml_ добавить этап запуска написанного скрипта

![26](screens/26.png)

##### Сохранить дампы образов виртуальных машин

![27](screens/27.png)

> Не забудьте запустить пайплайн с последним коммитом в репозитории.

![30](screens/30.png)

![28](screens/28.png)

### Part 6. Дополнительно. Уведомления

**== Задание ==**

##### Настроить уведомления о успешном/неуспешном выполнении пайплайна через бота с именем "[ваш nickname] DO6 CI/CD" в *Telegram*

> Текст уведомления должен содержать информацию об успешности прохождения как этапа **CI**, так и этапа **CD**.
В остальном текст уведомления может быть произвольным.

* Создаем бота в botfather 

![31](screens/31.png)

* У нас есть токен, осталось узнать айди чата, это можно сделать большим колличесвом способов, но я использовала бот 

![32](screens/32.png)

* Далее пишем нужный нам скрипт, который будет отрабатывать бот 

![33](screens/33.png)

* Добавляем эту строчку в скрипт после каждой стадии 

![35](screens/35.png)

* Пушим и проверяем, что уведомления доходят 

![34](screens/34.jpg)
 
